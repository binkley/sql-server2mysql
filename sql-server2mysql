#!/bin/bash

# Uses long options and modern getopt.  Validate this assumption
getopt -T 2>/dev/null
case $? in
4 ) ;; # Good - see getopt(1)
* ) echo "$0: Wrong getopt, sorry" >&2 ; exit 4 ;;
esac

function usage()
{
    echo "usage: $0 [-dhv]"
}

function help()
{
    usage
    cat <<EOH
  -d  (debug) More helpful output
  -h  (help) Print help and exit
  -v  (verbose) Explain processing
EOH
}

shopt -s nocasematch

debug=false
verbose=false

args=$(getopt -n "$0" -l debug,help,verbose -o dhv -s bash -- "$@") || exit $?
set - $args

while getopts :dhv-: opt
do
    case "$opt" in
    d ) debug=true ;;
    h ) help ; exit 0 ;;
    v ) verbose=true ;;
    - ) case $OPTARG in
        debug ) debug=true ;;
        help ) help ; exit 0 ;;
        verbose ) verbose=true ;;
        * ) usage >&2 ; exit 2 ;;
        esac ;;
    * ) usage >&2 ; exit 2 ;;
    esac
done
shift $((OPTIND - 1))

if $debug
then
    export PS4='$0:$LINENO+ '
    set -x
fi

while IFS='' read line
do
    # MySQL requires space after -- in comments
    line="${line/--/-- }"
    # Always strip square brackets from identifiers
    line="${line//[/}"
    line="${line//]/}"
    # GO becomes semicolon
    [[ "$line" =~ ^( *)GO( *)$ ]] && line="${BASH_REMATCH[1]};${BASH_REMATCH[2]}"

    echo "$line"
done
