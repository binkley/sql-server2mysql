#!/bin/bash

# Uses long options and modern getopt.  Validate this assumption
getopt -T 2>/dev/null
case $? in
4 ) ;; # Good - see getopt(1)
* ) echo "$0: Wrong getopt, sorry" >&2 ; exit 4 ;;
esac

function usage()
{
    echo "usage: $0 [-dhv]"
}

function help()
{
    usage
    cat <<EOH
  -d  (debug) More helpful output
  -h  (help) Print help and exit
  -v  (verbose) Explain processing
EOH
}

shopt -s nocasematch

debug=false
verbose=false

args=$(getopt -n "$0" -l debug,help,verbose -o dhv -s bash -- "$@") || exit $?
set - $args

while getopts :dhv-: opt
do
    case "$opt" in
    d ) debug=true ;;
    h ) help ; exit 0 ;;
    v ) verbose=true ;;
    - ) case $OPTARG in
        debug ) debug=true ;;
        help ) help ; exit 0 ;;
        verbose ) verbose=true ;;
        * ) usage >&2 ; exit 2 ;;
        esac ;;
    * ) usage >&2 ; exit 2 ;;
    esac
done
shift $((OPTIND - 1))

if $debug
then
    export PS4='$0:$LINENO+ '
    set -x
fi

go_re='^ *GO *$'
set_re='^ *SET +[^@]'
proc_re='^ *CREATE +PROCEDURE'
proc_end='^ *AS *$'
in_proc=false
local_var_re='^ *SET +@'
temp_table_re='^ *CREATE +TABLE +#(.*)'
temp_table_end='^ *\) *$'  # TODO: What if ) is on previous line?
in_temp_table=false

while IFS='' read line
do
    line="${line/--/-- }"  # --Comment -> -- Comment
    line="${line//[/}"  # [some].[id] -> some.id
    line="${line//]/}"

    if [[ "$line" =~ $go_re ]]
    then
        line=';'  # GO -> ;
    elif [[ "$line" =~ $set_re ]]
    then
        line="-- $line"  # SET FOO ON -> -- SET FOO ON
    elif [[ "$line" =~ $proc_re ]]
    then
        line="$line("  # DECLARE PROCEDURE bob -> DECLARE PROCEDURE bob(
        in_proc=true
    elif [[ "$line" =~ $proc_end ]]
    then
	line=')'  # AS -> ) for stored procedure params
        in_proc=false
    elif $in_proc
    then
        line="${line/@/IN }"  # @SomeParam AS CHAR(1) -> IN SomeParam CHAR(1)
        line="${line/ AS/}"
    elif [[ "$line" =~ $local_var_re ]]
    then
        line="$line;"
    elif [[ "$line" =~ $temp_table_re ]]
    then
        line="CREATE TEMPORARY TABLE ${BASH_REMATCH[1]}"
        in_temp_table=true
    elif $in_temp_table && [[ "$line" =~ $temp_table_end ]]
    then
        line=');'
        in_temp_table=false
    fi

    echo "$line"
done
